<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
  </head>
  <body>
    <script>
        const datas = [];
        const width = 1200;
        const height = 1000;
        let dataLoaded = false;
        let jsonData;
        let previousRoot;
        const stack = [];
        let currentLevel; 
        
        d3.json("https://raw.githubusercontent.com/Jojo08112000/Jojodiscovery/main/dataV2.json")
        .then(function(data) {
          jsonData = data;
          dataLoaded = true;
          buildHierarchy();
          
        })
        .catch(function(error) {
          console.log(error);
        });
        
         function buildHierarchy() {
            if (!dataLoaded) {
              setTimeout(buildHierarchy, 100);
              return;
        }

        jsonData.forEach(function(obj) {
          if (obj.entite_daffectation) {
            datas.push({
              cuid: obj.cuid,
              entite: obj.entite_daffectation
            });
          }
        });
        
          const datastree = constructionhierarchique2(datas);
          console.log(datastree);
          
          const simpleHierarchy = convertToSimpleHierarchy2(datastree);
          console.log(simpleHierarchy);
      
          const root = d3.hierarchy(simpleHierarchy)
            .count(d => d.value ? 1 : 0);
          console.log(root);
          
          const treemap = d3.treemap()
            .size([width - 100, height - 100]);
          
          let mapData = treemap(root);
          
          const svgContainer = d3.select("body").append("div")
            .style("display", "flex")
            .style("justify-content", "center")
            .style("align-items", "center");

          const svg = svgContainer.append("svg")
            .attr("height", height)
            .attr("width", width);

          
          const chart = svg.append("g")
            .attr("transform", `translate(${25},${25})`);
          
          const colorScale = d3.scaleOrdinal(d3.schemeCategory10)
            .domain(d3.extent(mapData.descendants(), n => n.height));
          
          const sizeScale = d3.scaleLinear()
            .domain([0, d3.max(mapData.descendants(), d => d.height)])
            .range([10, 50])
            

          function updateVisualization() {
            const filteredNodes = mapData.descendants().filter(d => mapData === d.parent);
            const node = chart.selectAll("g.node")
              .data(filteredNodes, d => `${d.data.name}-${d.depth}-${d.x0}-${d.y0}`);

          
            node.exit()
              .transition()
              .duration(500)
              .style("opacity", 0)
              .remove();
          
            const newNode = node
              .join("g")
              .attr("class", "node");
          
            newNode.attr("transform", d => `translate(${d.x0},${d.y0})`);
            
            const tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("position", "absolute")
            .style("pointer-events", "none")
            .style("display", "none")
            .style("background-color", "rgba(0, 0, 0, 0.8)")
            .style("color", "#fff")
            .style("padding", "8px")
            .style("font-size", "20px");
             

            newNode.append("rect")
              .attr("width", d => sizeScale(d.depth) * (d.x1 - d.x0))
              .attr("height", d => sizeScale(d.depth) * (d.y1 - d.y0))
              .style("fill", d => colorScale(d.height))
              .style("stroke", "white")
              .style("stroke-width", 5)
              //.style("fill", d => colorScale(d.height))
              //.style("fill", "#FFA500")
              .style("fill", d => color(d.height))
              .on("click", zoomIn)
              .on("contextmenu", zoomOut)
              .on("mouseover", function (event, d) {
                  const tooltip = d3.select(".tooltip");
                  const sum = d3.sum(d.descendants(), node => node.data.value || 0);
                  const info = [
                    `<strong>Name:</strong> ${d.data.name}`,
                    `<strong>Parent:</strong> ${d.parent ? d.parent.data.name : ""}`,
                    `<strong>Utilisateurs:</strong> ${sum}`
                  ];
                  tooltip
                    .style("display", "block")
                    .style("left", event.pageX + "px")
                    .style("top", event.pageY + "px")
                    .html(info.join("<br>"));
                })
                .on("mouseout", function () {
                  d3.select(".tooltip").style("display", "none");
                });
              
              
            
            newNode.merge(node)
            .transition()
            .duration(500)
            .attr("transform", d => `translate(${d.x0 + 1},${d.y0 + 1})`)
            .style("opacity", 1)
            .select("rect")
            .attr("width", d => sizeScale(d.depth) * (d.x1 - d.x0))
            .attr("height", d => sizeScale(d.depth) * (d.y1 - d.y0));

            
            newNode.append("text")
              .attr("dx", 4)
              .attr("dy", 14)
              .style("font-size", "17px")
              .style("font-weight", "bold")
              .attr("fill" , "white")
              .text(d => `${d.data.name}`);
          }

          function zoomIn(event, d) {
            if (d.children) {
              previousRoot = d;
              stack.push(previousRoot);
              const newRoot = d3.hierarchy(d.data)
              .sort((a, b) => b.value - a.value)
              .count(d => d.values ? d.values.length : 0);
              mapData = treemap(newRoot);
              updateVisualization();
              event.stopPropagation();
            }
          }

          function zoomOut(event, d) {
            if ( previousRoot) {
              previousRoot = stack.pop();
              const newRoot = previousRoot.parent || previousRoot;
              mapData = treemap(newRoot);
              updateVisualization();
              event.stopPropagation();
            }
          }
          
          document.addEventListener("contextmenu", function (event) {
            event.preventDefault();
          });

          updateVisualization();

    }
         
        function color(a){
          if(a%2===0){ return "#FFA500"; }
          if(a%2===1){ return "#000000"; }
        } 
        function constructionhierarchique2(datas){
            const datashierarchy = {};
            
            datas.forEach(function(data){
                const parts = data.entite.split("/");
                let currentLevel = datashierarchy;
                let nbr=0;
                for(let i = 0; i < parts.length; i++){
                  const part = parts[i]; 
                  if(!currentLevel.hasOwnProperty(part)){
                    currentLevel[part] = {};
                  }
                  currentLevel = currentLevel[part];
                  if(!parts[i+1]){
                    if (!currentLevel.hasOwnProperty('users')) {
                      currentLevel['users'] = nbr;//{nombres : nbr};
                      //currentLevel['users'] = [];
                    }
                    nbr = currentLevel['users'] + 1 ;
                    delete currentLevel['users'];
                    currentLevel['users'] = nbr;
                    //currentLevel['users'].push({cuid : data.cuid})
                  }
                }
              
            });
            const a = datashierarchy.orange;
            return a;
        }
        
        
        function convertToSimpleHierarchy2(data) {
          const hierarchy = {
              name: "root",
              children: []
            };
          
            const stack = [{
              parent: hierarchy,
              data: data
            }];
          
            while (stack.length > 0) {
              const node = stack.pop();
              const parent = node.parent;
              const data = node.data;
          
              for (const key in data) {
                if (key === "users") {
                  const value = data[key];
                  parent.value = value;
                  delete data[key];
                } else {
                  const childData = data[key];
                  const child = {
                    name: key,
                    children: []
                  };
          
                  if (typeof childData === "object" && Object.keys(childData).length > 0) {
                    stack.push({
                      parent: child,
                      data: childData
                    });
                  }
          
                  parent.children.push(child);
                }
              }
            }
          
            return hierarchy;
        }
      
      
    </script>
  </body>
</html>